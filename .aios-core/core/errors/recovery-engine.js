/**
 * RecoveryEngine - Error recovery suggestions and auto-fix
 *
 * Provides:
 * - Recovery suggestions based on error codes
 * - Auto-fix capability for recoverable errors
 * - Integration with health-check healers
 *
 * @module .aios-core/core/errors/recovery-engine
 * @see Story STORY-OPT-D2
 */

const fs = require('fs');
const path = require('path');
const AIOSError = require('./base-error');
const ErrorCodes = require('./error-codes');

/**
 * Built-in healer definitions for common errors
 * @constant {Object}
 */
const BUILTIN_HEALERS = {
  CFG_001: {
    name: 'ConfigInitializer',
    description: 'Creates default AIOS configuration file',
    canAutoFix: true,
    requiresConfirmation: false,
    fix: async (error, options) => {
      const projectRoot = options.projectRoot || process.cwd();
      const configPath = path.join(projectRoot, '.aios-core', 'core-config.yaml');
      const actions = [];

      // Ensure .aios-core directory exists
      const aiosDir = path.join(projectRoot, '.aios-core');
      if (!fs.existsSync(aiosDir)) {
        if (!options.dryRun) {
          fs.mkdirSync(aiosDir, { recursive: true });
        }
        actions.push(`Created directory: ${aiosDir}`);
      }

      // Create default config if not exists
      if (!fs.existsSync(configPath)) {
        const defaultConfig = `# AIOS Core Configuration
# Generated by AIOS Recovery Engine

version: "1.0"
project:
  name: "My Project"
  description: ""

agents:
  defaultAgent: "@dev"

logging:
  level: "info"
  path: ".aios/logs"
`;
        if (!options.dryRun) {
          fs.writeFileSync(configPath, defaultConfig, 'utf8');
        }
        actions.push(`Created config file: ${configPath}`);
      }

      return {
        success: true,
        actions,
        warnings: [],
      };
    },
  },

  CFG_002: {
    name: 'ConfigValidator',
    description: 'Validates and suggests fixes for configuration values',
    canAutoFix: true,
    requiresConfirmation: true,
    fix: async (error, options) => {
      // This healer provides guidance rather than making changes
      return {
        success: false,
        actions: [],
        warnings: ['Configuration validation requires manual review'],
        message: 'Please check the configuration value manually',
      };
    },
  },

  CFG_003: {
    name: 'ConfigParser',
    description: 'Attempts to fix YAML/JSON parse errors',
    canAutoFix: true,
    requiresConfirmation: false,
    fix: async (error, options) => {
      const context = error.context || {};
      const actions = [];

      if (context.file) {
        actions.push(`Review file: ${context.file}`);
        actions.push('Check for YAML syntax errors (indentation, quotes, colons)');
        actions.push('Use a YAML linter to validate');
      }

      return {
        success: false,
        actions,
        warnings: ['Automatic fix not possible for parse errors'],
        message: 'Manual intervention required to fix syntax errors',
      };
    },
  },

  CFG_004: {
    name: 'ConfigCompleter',
    description: 'Adds missing recommended configuration fields',
    canAutoFix: true,
    requiresConfirmation: true,
    fix: async (error, options) => {
      return {
        success: false,
        actions: ['Add the missing field to configuration'],
        warnings: ['Review the documentation for recommended fields'],
      };
    },
  },

  SYS_003: {
    name: 'InstallationRepair',
    description: 'Repairs corrupted AIOS installation',
    canAutoFix: true,
    requiresConfirmation: true,
    fix: async (error, options) => {
      const actions = [];

      actions.push('Run: npx aios-core doctor');
      actions.push('Check for missing files in .aios-core/');
      actions.push('Reinstall AIOS if necessary: npx aios-core install');

      return {
        success: false,
        actions,
        warnings: ['Some repairs may require manual intervention'],
      };
    },
  },

  IDS_003: {
    name: 'IDSRegistryRepair',
    description: 'Attempts to repair corrupted IDS registry',
    canAutoFix: true,
    requiresConfirmation: false,
    fix: async (error, options) => {
      const projectRoot = options.projectRoot || process.cwd();
      const registryPath = path.join(projectRoot, '.aios-core', 'data', 'ids-registry.json');
      const actions = [];

      // Check if registry file exists
      if (fs.existsSync(registryPath)) {
        try {
          const content = fs.readFileSync(registryPath, 'utf8');
          JSON.parse(content); // Validate JSON
          actions.push('Registry file is valid JSON');
          return {
            success: true,
            actions,
            warnings: [],
          };
        } catch (parseError) {
          actions.push('Registry file contains invalid JSON');
          actions.push('Manual repair or restoration from backup required');
          return {
            success: false,
            actions,
            warnings: ['Cannot automatically repair corrupted JSON'],
          };
        }
      }

      actions.push('Registry file not found');
      return {
        success: false,
        actions,
        warnings: [],
      };
    },
  },
};

/**
 * RecoveryEngine - Provides recovery suggestions and auto-fix
 *
 * @class RecoveryEngine
 *
 * @example
 * const engine = new RecoveryEngine('/path/to/project');
 * const suggestions = engine.getRecoverySuggestions(error);
 * if (engine.canAutoFix(error)) {
 *   await engine.executeAutoFix(error);
 * }
 */
class RecoveryEngine {
  /**
   * Create a new RecoveryEngine
   * @param {string} [projectRoot=process.cwd()] - Project root directory
   */
  constructor(projectRoot = process.cwd()) {
    this.projectRoot = projectRoot;
    this.healers = this.loadHealers();
  }

  /**
   * Load healer definitions
   * @returns {Object} Healer definitions
   */
  loadHealers() {
    return { ...BUILTIN_HEALERS };
  }

  /**
   * Get recovery suggestions for an error
   *
   * @param {AIOSError|Error|null} error - Error to get suggestions for
   * @returns {Object} Recovery suggestions
   * @returns {string} returns.message - Error message
   * @returns {string[]} returns.steps - Recovery steps
   * @returns {boolean} returns.canAutoFix - Whether auto-fix is available
   * @returns {string|null} returns.docUrl - Documentation URL
   */
  getRecoverySuggestions(error) {
    // Handle null/undefined
    if (error == null) {
      return {
        message: 'Unknown error',
        steps: ['Try the operation again', 'Check logs for details'],
        canAutoFix: false,
        docUrl: null,
      };
    }

    const isAios = error instanceof AIOSError;
    const message = error.message || 'An unexpected error occurred';

    if (!isAios) {
      // Generic error - provide generic suggestions
      return {
        message,
        steps: [
          'Try the operation again',
          'Check error details for more information',
          'Consult documentation if problem persists',
        ],
        canAutoFix: false,
        docUrl: null,
      };
    }

    // AIOSError - use error code definition
    const code = error.code;
    const recoverySteps = error.recoverySteps || [];
    const docUrl = error.docUrl;
    const canAutoFix = this.canAutoFix(error);

    // Get additional info from error codes definition
    const errorDef = ErrorCodes.getError(code);
    const additionalSteps = errorDef?.recoverySteps || [];

    // Combine steps, removing duplicates
    const allSteps = [...recoverySteps];
    additionalSteps.forEach((step) => {
      if (!allSteps.includes(step)) {
        allSteps.push(step);
      }
    });

    return {
      message,
      steps: allSteps,
      canAutoFix,
      docUrl,
      code,
      category: error.category,
      severity: error.severity,
    };
  }

  /**
   * Check if an error can be auto-fixed
   *
   * @param {AIOSError|Error} error - Error to check
   * @returns {boolean} True if auto-fix is available
   */
  canAutoFix(error) {
    if (error == null) {
      return false;
    }

    const isAios = error instanceof AIOSError;

    // Must be AIOSError with code
    if (!isAios || !error.code) {
      return false;
    }

    // Check if error is recoverable
    if (error.recoverable === false) {
      return false;
    }

    // Check if healer exists
    const healer = this.healers[error.code];
    return healer?.canAutoFix === true;
  }

  /**
   * Execute auto-fix for an error
   *
   * @param {AIOSError|Error} error - Error to fix
   * @param {Object} [options={}] - Fix options
   * @param {boolean} [options.dryRun=false] - Preview mode (don't apply changes)
   * @returns {Promise<FixResult>} Fix result
   */
  async executeAutoFix(error, options = {}) {
    const defaultResult = {
      success: false,
      actions: [],
      warnings: [],
      message: '',
      dryRun: options.dryRun || false,
    };

    // Handle null/undefined
    if (error == null) {
      return {
        ...defaultResult,
        message: 'Cannot fix null/undefined error',
      };
    }

    // Check if auto-fix is available
    if (!this.canAutoFix(error)) {
      return {
        ...defaultResult,
        message: `Cannot auto-fix error: ${error.code || 'unknown'}`,
      };
    }

    const healer = this.healers[error.code];
    if (!healer || !healer.fix) {
      return {
        ...defaultResult,
        message: `No fix function available for error: ${error.code}`,
      };
    }

    try {
      // Prepare fix options
      const fixOptions = {
        ...options,
        projectRoot: this.projectRoot,
      };

      // If dry run, provide preview
      if (options.dryRun) {
        return {
          ...defaultResult,
          dryRun: true,
          preview: {
            healer: healer.name,
            description: healer.description,
            requiresConfirmation: healer.requiresConfirmation,
          },
          message: 'Dry run - no changes applied',
        };
      }

      // Execute fix
      const result = await healer.fix(error, fixOptions);

      return {
        ...defaultResult,
        success: result.success !== false,
        actions: result.actions || [],
        warnings: result.warnings || [],
        message: result.message || (result.success ? 'Fix applied successfully' : 'Fix failed'),
      };
    } catch (fixError) {
      return {
        ...defaultResult,
        success: false,
        error: fixError.message,
        message: `Fix execution failed: ${fixError.message}`,
      };
    }
  }

  /**
   * Get healer for an error code
   *
   * @param {string} code - Error code
   * @returns {Object|null} Healer definition or null
   */
  getHealer(code) {
    if (!code || typeof code !== 'string') {
      return null;
    }
    return this.healers[code] || null;
  }

  /**
   * Register a custom healer
   *
   * @param {string} code - Error code to handle
   * @param {Object} healer - Healer definition
   * @param {string} healer.name - Healer name
   * @param {string} healer.description - Healer description
   * @param {boolean} healer.canAutoFix - Whether auto-fix is possible
   * @param {boolean} healer.requiresConfirmation - Whether fix requires confirmation
   * @param {Function} healer.fix - Fix function (async)
   */
  registerHealer(code, healer) {
    if (!code || !healer) {
      return;
    }
    this.healers[code] = healer;
  }
}

/**
 * Suggest fix for an error (convenience function)
 *
 * @param {AIOSError|Error} error - Error to get suggestions for
 * @param {Object} [options={}] - Options
 * @param {string} [options.projectRoot] - Project root directory
 * @returns {Object} Recovery suggestions
 */
function suggestFix(error, options = {}) {
  const engine = new RecoveryEngine(options.projectRoot);
  return engine.getRecoverySuggestions(error);
}

module.exports = {
  RecoveryEngine,
  suggestFix,
  BUILTIN_HEALERS,
};
